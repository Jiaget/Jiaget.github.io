
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Jiaget&#39;s field">
    <title>归档: 2021/6 - Jiaget&#39;s field</title>
    <meta name="author" content="Jiaget">
    
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Jiaget&#39;s field">
<meta property="og:url" content="http://example.com/archives/2021/06/index.html">
<meta property="og:site_name" content="Jiaget&#39;s field">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jiaget">
<meta name="twitter:card" content="summary">
    
        <link rel="publisher" href="https://plus.google.com/none"/>
    
    
        
    
    
        <meta property="og:image" content="http://example.com/assets/images/Avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-sp5xih4wwpbivuctnupxctktdmpz7mk0p2tqxrvmeluf5fjmhxycv6yumqgk.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Jiaget&#39;s field
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Avatar.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Avatar.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">Jiaget</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="归档"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/06/24/%E4%B8%80%E4%B8%AAgoroutine%E7%9A%84%E4%B8%80%E7%94%9F/"
                            aria-label=": 一个goroutine的一生"
                        >
                            一个goroutine的一生
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-06-24T13:25:09+08:00">
	
		    6月 24, 2021
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/golang/">golang</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>一个函数被编译成可执行文件以后，会通过 <code>程序执行入口</code> 进入内存虚拟地址空间中的代码段。</p>
<p>对于一个 main 函数而言， 程序会以 <code>runtime.main</code> 作为入口， 创建一个 <code>main goroutine</code>, 之后再去调用 <code>main.main</code> 函数。</p>
<p>提到 Golang 的协程运行，就不得不提 <code>GMP</code> 模型, 在虚拟地址空间的 <code>数据段</code> 会记录这样的全局变量：</p>
<ul>
<li><p>g0 （主协程）</p>
<ul>
<li>g0 会在主线程栈上分配栈空间</li>
<li>g0 持有 m0 指针</li>
</ul>
</li>
<li><p>m0</p>
<ul>
<li>m0 即主线程所对应的m</li>
<li>m0 持有 g0 的指针，且m0上运行的第一个g就是g0</li>
</ul>
</li>
<li><p>allgs: 记录所有的g</p>
</li>
<li><p>allm: 记录所有的m</p>
</li>
<li><p>allp: 在程序初始化的过程中，调度器会进行初始化，根据环境变量 GOMAXPROCS 来决定创建 p 的个数。</p>
<ul>
<li>同样， 第一个被创建的p，会和m0相关联。</li>
</ul>
</li>
<li><p>sched: 调度器</p>
<ul>
<li>记录所有空闲的 m 和 p</li>
<li>runq</li>
</ul>
</li>
<li><p>runq：runq作为全局变量，记录在 <code>sched</code> 下</p>
<ul>
<li>这里的runq是全局runq</li>
<li>当然还有一个本地runq， 记录在P中。</li>
</ul>
</li>
</ul>
<h2 id="本地队列与全局队列"><a href="#本地队列与全局队列" class="headerlink" title="本地队列与全局队列"></a>本地队列与全局队列</h2><p>runq， 在 <code>runtime.p</code> 中记录的是本地队列，在 <code>runtime.schedt</code> 中记录的是全局队列。</p>
<p>当本地队列满了，G就会放在全局队列中。 m 优先获取本地队列的 g， 再从全局队列中获取，当 本地和全局都没有 g ， 它会从其他 m 中分担一些 g。</p>
<h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h2><p>回到main函数的执行过程中来。</p>
<p>main函数执行过程中需要创建的 main goroutine， 会被加入到 allp[0] 的本地队列中， 之后会通过 mstart 函数开启调度循环(schedule()),调度器将队列中的 g 调度到m0上去执行。</p>
<p>main goroutine 的工作不仅仅是调用 main 函数， 它还会开启线程监控， 包初始化等工作， 准备工作结束后，执行完 main 函数后， goroutine 便退出。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/06/24/%E4%B8%80%E4%B8%AAgoroutine%E7%9A%84%E4%B8%80%E7%94%9F/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/06/23/%E8%AE%B0%E6%92%B8%E4%B8%80%E4%B8%AA%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%BF%AB%E6%8E%92/"
                            aria-label=": 记撸一个双链表快排"
                        >
                            记撸一个双链表快排
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-06-23T11:00:45+08:00">
	
		    6月 23, 2021
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>刷面筋的时候看到有问双链表排序问题。</p>
<p>正想着用快排怎么排序双链表，写的时候各种空指针。写完后顺便记录一下爬坑过程吧。</p>
<p>双链表的结构体构思很简单。一开始就简单构造了一下，没想别的。</p>
<pre><code>type dLinkedList struct &#123;
    Data  int
    Prev  *dLinkedList
    Next  *dLinkedList
&#125;
</code></pre>
<p>顺便写一下构造函数，包括随机数的生成呀，什么的。因为建链表的时候不想把for循环拆开讨论，直接建了一个前置节点，只要后面销毁就好了。顺便写好打印函数，测试一下。双链表就这么构造好了，一切都很顺利。</p>
<pre><code>func NewNode(x int) *dLinkedList &#123;
    return &amp;dLinkedList&#123;
        Data:  x,
    &#125;
&#125;

func (d *dLinkedList) AddNode(x) &#123;
    node := NewNode(x)
    d.Next = node
    node.Prev = d
&#125;

func (d *dLinkedList) Print() &#123;
    cur := d
    for cur != nil &#123;
        fmt.Printf(&quot;%d &quot;, cur.Data)
        cur = cur.Next
    &#125;
    fmt.Println()
&#125;

func GenDLL(size, min, max int) *dLinkedList &#123;
    nums := Generate(size, min, max)
    head := NewNode(0)
    cur := head
    for i := 0; i &lt; len(nums); i++ &#123;
        cur.AddNode(nums[i])
        cur = cur.Next
    &#125;
    head = head.Next
    head.Prev = nil
    return head
&#125;
</code></pre>
<p>数组的快排非常简单，分治的思想，首尾指针不断向中心移动，和 <code>pivot</code> 对比决定是否交换。</p>
<p>到了链表这里，一些细节就需要处理，比如，首尾指针怎么判断是否相交？pivot 取哪个？</p>
<p>懒人总是想用莫名奇妙的方法去实现，明明知道它不合理，但不想修改原来的代码，就算只是加个索引，这么简单的事情也懒得去做。（我也是服了自己了）。为了不想修改原先的代码，判断首尾指针相交，我只是简单比较了两个节点是否相等，并考虑到两个节点错位一格的情况，实际细想，也有错位两格的特殊情况。</p>
<p>果然，这种脆弱的代码根本不会给我老老实实排好序，因为我就算解决了首尾指针相交的问题，在进入递归的部分，选取递归范围又犯了难，不使用索引来判断范围是否合法是不简单的事情，当然可以写一个函数来判断范围是否合法，但是链表的遍历是非常耗费时间的事情。增加时间复杂度很显然不应该去做。最后，还是老老实实给每一个节点增加了索引。</p>
<p>接着就是 pivot 的选取了。</p>
<p>最开始学的算法书写的 pivot 取数组第一个值就可以了。当然这在数组里倒是没什么问题，到了链表，就会出现空指针引用的问题。当然，没有思考这是为什么，只是简单的把 pivot 换成了链表中心的值，我只是希望 pivot 尽可能不要跑到两边的位置。</p>
<p>要在脑子里模拟快排的每一步细节是很吃力的事情，天生犯懒的我也就这样过了。</p>
<p>最后就是<a target="_blank" rel="noopener" href="https://github.com/Jiaget/notes/blob/main/algorithm/d-linked-list.go">双向链表的代码了</a></p>
<p>唉，算法苦手~</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/06/23/%E8%AE%B0%E6%92%B8%E4%B8%80%E4%B8%AA%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%BF%AB%E6%8E%92/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/06/23/Golang%E4%B9%8B%E5%8F%8D%E5%B0%84/"
                            aria-label=": Golang之反射"
                        >
                            Golang之反射
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-06-23T09:12:59+08:00">
	
		    6月 23, 2021
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/golang/">golang</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>反射的作用只是将类型元数据返回给用户。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/06/23/Golang%E4%B9%8B%E5%8F%8D%E5%B0%84/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/06/20/%E7%AA%A5%E6%8E%A2Gin%E6%A1%86%E6%9E%B6/"
                            aria-label=": 窥探Gin框架"
                        >
                            窥探Gin框架
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-06-20T14:25:35+08:00">
	
		    6月 20, 2021
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Gin/">Gin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>几个月前，为了学习Gin框架的基本使用（实际还有许多Golang其他的工具框架），从头搭建了一个简易的服务端+客户端 – <a target="_blank" rel="noopener" href="https://github.com/Jiaget/simplebank">一个简易的银行系统</a></p>
<p>作为练手项目，Gin有很多特性与功能都没有研究与使用过， 这次的学习希望可以从深度和广度两个方面，更加全面的一窥Gin框架，这个活跃在社区广受好评的web框架。</p>
<h1 id="回顾-HTTP-服务开发的基本流程"><a href="#回顾-HTTP-服务开发的基本流程" class="headerlink" title="回顾 HTTP 服务开发的基本流程"></a>回顾 HTTP 服务开发的基本流程</h1><ul>
<li>开启TCP 监听</li>
<li>初始化一些 <code>handler</code> 处理具体的业务逻辑</li>
<li>将业务逻辑和相关的 <code>Method</code>, <code>URL</code> 绑定，对外暴露一些具体功能服务</li>
</ul>
<h1 id="Gin-的几个重要模型："><a href="#Gin-的几个重要模型：" class="headerlink" title="Gin 的几个重要模型："></a>Gin 的几个重要模型：</h1><ul>
<li><p>Engine </p>
<ul>
<li>初始化一个 <code>gin</code> 对象实例，该对象实例中包含一些框架的基础功能， <code>日志</code>, <code>中间件设置</code>, <code>路由控制</code>, <code>handlercontext</code></li>
</ul>
</li>
<li><p>Router:</p>
<ul>
<li>定义路由规则与条件，通过HTTP服务将具体路由注册到一个 <code>context</code> 实现的Handler 中</li>
</ul>
</li>
<li><p>Context:</p>
<ul>
<li>该模块是框架中重要的一环，它可以让我们在中间件中共享变量，管理整个流程，验证请求的json， 提供一个json的响应。</li>
</ul>
</li>
<li><p>Bind:</p>
<ul>
<li>context 中，可以获取到请求的详细信息（ HTTP 的 head 和 body）</li>
<li>但是我们需要根据不同的HTTP协议参数获取相应的格式化数据，来处理底层的业务逻辑，这需要我们使用 <code>bind</code> 相关的方法来解析 HTTP数据。</li>
</ul>
</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/06/20/%E7%AA%A5%E6%8E%A2Gin%E6%A1%86%E6%9E%B6/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
                            aria-label=": 设计模式"
                        >
                            设计模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-06-19T13:01:41+08:00">
	
		    6月 19, 2021
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>简述一下各个设计模式，顺便用Golang实现。</p>
<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>根据参数的不同，返回不同类的实例。简单工厂模式定义一个类来负责创建其他类的实例。</p>
<p>Golang的设计理念弱化了面向对象的概念，它没有构造函数的概念，但规范化的代码会使用Newxx的函数来初始化类。</p>
<h3 id="简单工厂的优点"><a href="#简单工厂的优点" class="headerlink" title="简单工厂的优点"></a>简单工厂的优点</h3><ul>
<li>客户端不需要直接创建对象实例，会有专门的工厂类用于这类工作</li>
<li>换句话说，客户端无需知道产品类的类名，只需要知道对应参数，而对应参数名的命名只需要规范，易读</li>
<li>可以引入配置文件，在不修改代码的情况下更改产品类。</li>
</ul>
<h3 id="简单工厂的缺点"><a href="#简单工厂的缺点" class="headerlink" title="简单工厂的缺点"></a>简单工厂的缺点</h3><ul>
<li>工厂类担负的责任过重，一旦不能工作，整个系统都会被影响</li>
<li>增加了系统类的个数，复杂度增加（虽然在工厂模式中是简单的实现）</li>
<li>扩展困难，增加新的产品类，就要修改工厂逻辑</li>
</ul>
<p><img src="https://github.com/Jiaget/notes/blob/main/patterns/simple/simple.go" alt="简单工厂demo"></p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>简单方法模式将代码逻辑压力集中在了一个工厂类上面，工厂方法模式显然希望缓解工厂类的压力而设计出来的。</p>
<p>我们会先定义一个抽象工厂类，再定义具体的工厂类来实现不同的产品。这种模式下，当出现新的产品，只需要为这个产品创建一个具体的工厂类即可获取新的实例。</p>
<p><img src="https://github.com/Jiaget/notes/blob/main/patterns/factory_method/factory_method.go" alt="工厂方法demo"></p>
<h3 id="工厂方法优点"><a href="#工厂方法优点" class="headerlink" title="工厂方法优点"></a>工厂方法优点</h3><ul>
<li>工厂方法模式中，工厂方法创建产品，并隐藏产品类将被实例化的细节。只需关系产品对应的工厂，无需知道类名。</li>
<li>多态，可以使工厂自主确定创建何种产品。所有的具体工厂都有同一个抽象的父类。（Golang实现继承需要通过接口的特性，使用组合来实现。）</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/06/18/golang%E7%9A%84GC-%E4%BA%8C/"
                            aria-label=": GC(二)"
                        >
                            GC(二)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-06-18T19:12:55+08:00">
	
		    6月 18, 2021
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/golang/">golang</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>之前，主要讲了golang的三色标记法以及混合写屏障机制。这里简略介绍一下一些GC机制。</p>
<h2 id="简述三色标记法"><a href="#简述三色标记法" class="headerlink" title="简述三色标记法"></a>简述三色标记法</h2><p>三色标记法是一种追踪式回收机制：</p>
<ul>
<li>垃圾回收开始时：所有数据标记为白色</li>
<li>将可以追踪到的root节点标记为灰色（灰色表示由当前节点展开的追踪还未完成）</li>
<li>当该节点追踪任务完成，该节点标记为黑色，并无需再次基于它展开追踪</li>
<li>由黑色节点追踪到的节点会被标记为灰色。</li>
<li>当所有的灰色节点都被标记为黑色时，标记工作完成</li>
<li>白色节点均为垃圾</li>
</ul>
<h2 id="标记清除带来的问题"><a href="#标记清除带来的问题" class="headerlink" title="标记清除带来的问题"></a>标记清除带来的问题</h2><p>内存碎片化，回收的内存很难保证能成片聚在一起。而这些小块内存碎片会导致找出合适的内存空间进行分配的工作将付出更高的代价。甚至一些小块内存永远无法使用</p>
<h3 id="Bibop"><a href="#Bibop" class="headerlink" title="Bibop"></a>Bibop</h3><p>这是一种管理碎片化内存的机制，它将大小规格相同的内存碎片统一管理。从而快速匹配内存。</p>
<p>当然这个机制无法解决小内存无法使用的问题</p>
<h3 id="移动数据"><a href="#移动数据" class="headerlink" title="移动数据"></a>移动数据</h3><p>在标记清除算法中的标记阶段，会移动非垃圾数据，使它们尽可能紧凑地放在内存中。<br><img src="https://i.loli.net/2021/06/18/kUBnZb9fpEO1veG.png" alt="move.png"></p>
<p>缺点在于移动数据会带来不小的开销</p>
<h3 id="复制式回收"><a href="#复制式回收" class="headerlink" title="复制式回收"></a>复制式回收</h3><p>将内存划分为两个相等的空间 <code>From</code>, <code>To</code>。 程序执行使用 <code>From</code>空间，在垃圾回收扫描时，将能追踪的数据复制到 <code>To</code> 空间。所有空间复制完成后，将<code>From</code> 和 <code>To</code> 空间交换，并清除原<code>From</code>空间的数据。</p>
<p>这种方法会占用一般的内存空间，为了提高内存使用率，只会在一部分的内存空间使用，并搭配其他的回收机制。</p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><h3 id="弱分代假说"><a href="#弱分代假说" class="headerlink" title="弱分代假说"></a>弱分代假说</h3><p>大部分对象都在年轻时死亡。</p>
<p>我们将只存活1， 2次回收的对象称为新生代对象。而经历过多次垃圾回收的对象为老年代对象。实践证明，新生代对象成为垃圾的概率要高于老年代对象。</p>
<p>我们可以将数据分成新生代和老年代，降低老年代数据的垃圾回收扫描频率，这将提升垃圾回收效率。</p>
<h2 id="引用计数式垃圾回收"><a href="#引用计数式垃圾回收" class="headerlink" title="引用计数式垃圾回收"></a>引用计数式垃圾回收</h2><p>以上均为追踪式垃圾回收，引用计数式垃圾回收有所不同。</p>
<p>该垃圾回收在执行过程中，会更新对象的引用计数，当引用计数更新为0时，说明该数据不再有用，可以进行垃圾回收。这种回收机制可以将之前的追踪代价分摊到每次对数据的操作中。</p>
<p>但是，引用计数的均摊思路，如果在高频率开辟内存的场景下，仍然带来不小的开销。</p>
<h1 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h1><p>每种垃圾回收策略都无法完美解决各式各样的缺陷。同样的，以上的垃圾回收策略均无可避免的需要 <code>Stop the World</code>， 这将会暂停用户程序，为了避免长时间 STW 带给用户影响，我们可以将 STW 分成多次执行，将一次垃圾回收拆分成多次，和用户程序交替执行。这叫做 <code>增量式回收</code>。</p>
<p>这可能带来的问题是，在某段垃圾回收标记了一个黑色对象，用户程序立马修改它，导致垃圾回收机制的误判，这里就得使用 <code>读写屏障</code> 机制，详见上一篇文章。</p>
<h2 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h2><p>补充一个读屏障。</p>
<p>在 <code>FROM</code> <code>TO</code> 复制回收机制中。</p>
<p><img src="https://i.loli.net/2021/06/18/LP5Fzi1HGnc96AB.png" alt="fromti.png"></p>
<p>当A已经复制到 <code>to</code> 空间上后，用户程序读取了 <code>From</code> 空间的旧数据，B复制到了 A,由于B建立的指针指向了旧的A，当<code>FROM</code>空间被销毁，B指向的旧A也不复存在，此时再去访问旧A，就会出错。</p>
<p>此时需要引入一个读屏障：</p>
<ul>
<li>当我们读取的数据有新副本时，直接读取 <code>To</code> 空间的新副本。</li>
</ul>
<h1 id="多核"><a href="#多核" class="headerlink" title="多核"></a>多核</h1><p>多线程并行执行垃圾回收的场景，被称为 <code>并行垃圾回收</code>。</p>
<p>并发GC的问题在于，很容易导致有的协程的GC忙碌，而有的线程空闲。如果使用负载均衡，这也会带来同步的开销。</p>
<p>同时，并行GC还有的问题是，<code>FROM-TO</code>复制回收还需要避免数据对象被重复复制。</p>
<ul>
<li><p>用户程序和GC并行执行的垃圾回收被称为 <code>并发垃圾回收</code>。</p>
</li>
<li><p>在GC的某个阶段进行STW，被称为 <code>主体并发式垃圾回收</code></p>
</li>
<li><p>再增加增量垃圾回收机制，又会出现 <code>主题并发增量式垃圾回收</code></p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/06/18/GNYLQxF534jwTaU.png" alt="gc-type.png"></p>
<h1 id="Golang采用了哪些？"><a href="#Golang采用了哪些？" class="headerlink" title="Golang采用了哪些？"></a>Golang采用了哪些？</h1><p>Golang 采用了 三色标记法 的 <code>标记-清除</code> 算法 + 主体并发增量式回收 + 插入，删除的混合写屏障</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/06/18/golang%E7%9A%84GC-%E4%BA%8C/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/06/16/golang%E4%B9%8Bdefer%E5%92%8Cpanic/"
                            aria-label=": golang之defer和panic"
                        >
                            golang之defer和panic
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-06-16T18:12:34+08:00">
	
		    6月 16, 2021
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/golang/">golang</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="panic-和-defer-的一般执行流程"><a href="#panic-和-defer-的一般执行流程" class="headerlink" title="panic 和 defer 的一般执行流程"></a>panic 和 defer 的一般执行流程</h1><p>Golang的每一个goroutine上都会有 <code>*_defer</code>, <code>*_panic</code> 的头指针，每次发生新的panic， 都会在链表头上加入panic。defer与之类似。</p>
<p><img src="https://i.loli.net/2021/06/16/Y84sWgIQvpVmxwG.png" alt="case1.png"></p>
<p>在这个场景下，当程序执行到panic时，goroutine的defer链表已经储存了两个defer函数。此时，程序会先将panic储存到panic链表中，再从defer链表中取出defer函数执行。</p>
<p><img src="https://i.loli.net/2021/06/16/QYjncWOBK65s4gx.png" alt="link.png"></p>
<p>由panic触发的defer，在执行中有所不同。先看下defer的结构：</p>
<p><img src="https://i.loli.net/2021/06/16/NT9a4d5yDlSpOqh.png" alt="_defer.png"></p>
<ul>
<li>先将 <code>started</code> 置 <code>true</code></li>
<li>将 <code>_panic</code> 指向当前panic</li>
</ul>
<p>这种设计，是为了应对defer函数的执行失败。比如：</p>
<p><img src="https://i.loli.net/2021/06/16/5CMwiJmxZHaELfS.png" alt="case2.png"></p>
<p>我们让A1也发生panic。当程序执行到 <code>A1</code> 的 <code>panic</code> 时, <code>goroutine</code> 的 <code>_panic</code>链表又会增加一个 <code>panic</code> 。</p>
<p>此时，新的 <code>panic</code> 也会触发执行 <code>_defer</code> 链表中的函数，并发现第一个defer函数上标记的 <code>panic</code> 不是自己，此时，程序会将 <code>_panic</code> 链表中对应的 <code>panic</code> 中止。</p>
<p><img src="https://i.loli.net/2021/06/16/gHTuS8jRka1L4eh.png" alt="panic-shutdown.png"></p>
<p>此时，需要展示一下 <code>panic</code> 的结构体。</p>
<p><img src="https://i.loli.net/2021/06/16/EedOavxV5HyzwNk.png" alt="panic-struct.png"></p>
<p>最后， 在没有 <code>recover</code> 的情况下，<code>panic</code> 打印会从链表尾部，打印至头部。</p>
<h2 id="小结1"><a href="#小结1" class="headerlink" title="小结1"></a>小结1</h2><p>无 recover 的 panic 执行流程的要点在于：</p>
<ul>
<li><code>panic</code> 执行 <code>defer</code> 函数会先标记defer函数，目的是嵌套的 <code>panic</code> 可以中止之前的 <code>panic</code></li>
<li>所有的panic 都会输出，且顺序输出。</li>
</ul>
<h1 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h1><p><code>recover</code> 只会把 <code>panic</code> 结构体上的 <code>recovered</code> 字段置 <code>true</code>。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/06/16/golang%E4%B9%8Bdefer%E5%92%8Cpanic/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/06/16/tpc-%E7%B2%98%E5%8C%85/"
                            aria-label=": tpc 粘包"
                        >
                            tpc 粘包
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-06-16T13:24:47+08:00">
	
		    6月 16, 2021
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>socket网络编程采用端对端通信，可以使用 [<code>源IP</code>, <code>源端口</code>， <code>目的IP</code>, <code>目的端口</code>, <code>传输层协议</code>] 这样的五元组来描述一个连接。发送者往往发送多个包给接收者，为了更高效地发送数据包，采用了优化算法（<code>Nagle</code> 算法）， 将<code>多次</code>，<code>间隔小</code>,<code>数据量小</code>的数据，合并成一个数据量大的数据块，然后进行封装包。同时, 接收者也需要使用高效的拆包机制来分辨这些数据</p>
<h1 id="1-什么是TCP粘包"><a href="#1-什么是TCP粘包" class="headerlink" title="1.什么是TCP粘包"></a>1.什么是TCP粘包</h1><h2 id="发送者"><a href="#发送者" class="headerlink" title="发送者"></a>发送者</h2><p>TCP默认使用 <code>Nagle</code>算法，用于减少网络中报文数量，其主要：</p>
<ul>
<li><ol>
<li>只有当上一个分组得到确认后，才会发送下一个分组</li>
</ol>
</li>
<li><ol start="2">
<li>手机多个小分组，当确认到达后，一起发送</li>
</ol>
</li>
</ul>
<h2 id="接收者"><a href="#接收者" class="headerlink" title="接收者"></a>接收者</h2><p>TPC接收到数据包后，不会马上交给应用层处理，而是将其缓存，而应用程序需要主动从缓存中接收分组。</p>
<p>在这种情况下，当满足以下条件，就会发生TCP <code>粘包</code>:</p>
<ul>
<li>TPC接收数据包到缓存的速度大于应用程序从缓存读取数据包的数据。</li>
<li>当多个包被缓存，应用程序有可能读取到多个首尾相接的包。</li>
</ul>
<h2 id="可能产生的问题"><a href="#可能产生的问题" class="headerlink" title="可能产生的问题"></a>可能产生的问题</h2><p>比如写的一段程序，向服务端发送两次数据，我希望服务端分别对这两个数据进行处理，但是服务器在一次接收时，将两条数据都读出来了。如果没有很好地处理这个场景，数据很容易被错误处理，甚至被认为时错误而被丢掉，导致服务端不能高效处理服务。</p>
<h1 id="2-TCP粘包的谬误"><a href="#2-TCP粘包的谬误" class="headerlink" title="2.TCP粘包的谬误"></a>2.TCP粘包的谬误</h1><p>实际上<code>TCP粘包</code>这个名词本身就不合理，因为：</p>
<ul>
<li>TCP本身就没有包的概念， 它是一个面向流的协议</li>
<li>而所谓的粘包是指，开发者在应用层封装的数据，开发者希望TCP能将这些数据自动拆分，然而TCP为了节省流量，会将包合并后发送。这并不是TCP的问题。</li>
</ul>
<h1 id="3-解决思路"><a href="#3-解决思路" class="headerlink" title="3. 解决思路"></a>3. 解决思路</h1><ol>
<li>格式化数据：给每条数据都设置固定的格式，（开始符， 结束符）。特点简单，但是要保证开始符结束符不会出现在数据内部。</li>
<li>设置发送长度：发送数据时，将长度一并发送，这样应用层可以根据长度分辨数据的开始与结束</li>
</ol>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>TCP 粘包本身就不是问题，但是通过这个“问题”可以学到一些非常基本的网络编程的规范。（应用开发者应该解决好自己定义的数据包分包的问题，而不是交给TCP解决）</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/06/16/tpc-%E7%B2%98%E5%8C%85/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/06/09/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8Golang%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"
                            aria-label=": 深入探讨Golang的类型系统"
                        >
                            深入探讨Golang的类型系统
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-06-09T19:33:42+08:00">
	
		    6月 09, 2021
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/golang/">golang</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="先讲一讲Golang的方法"><a href="#先讲一讲Golang的方法" class="headerlink" title="先讲一讲Golang的方法"></a>先讲一讲Golang的方法</h1><pre><code>type T struct &#123;
    name string
&#125;
func (t T) F1() &#123;
    fmt.Println(t.name)
&#125;
func main()&#123;
    t := T&#123;name: &quot;a&quot;&#125;
    t.F1()
&#125;
</code></pre>
<p>像上面这段代码，我们定义了一个结构体，并给这个结构体关联了一个方法， 并使用 <code>t.F1()</code>语句调用了这个方法。</p>
<p>方法的本质是一个函数，只是这个函数在被调用时，接收者会作为第一个参数传入。（<code>t.F1()</code> 的本质是 <code>T.F1(t)</code>。 前者的写法只是语法糖）</p>
<p>在编译阶段，我们可以获取变量，类型，方法等参数。</p>
<p>到了执行阶段，像 <code>反射</code>， <code>接口</code>， <code>类型断言</code> 这类语言特性/ 机制，我们也需要动态获取数据类型信息。</p>
<h1 id="我们先看看Golang有哪些类型？"><a href="#我们先看看Golang有哪些类型？" class="headerlink" title="我们先看看Golang有哪些类型？"></a>我们先看看Golang有哪些类型？</h1><h2 id="内置类型-build-in"><a href="#内置类型-build-in" class="headerlink" title="内置类型(build-in)"></a>内置类型(build-in)</h2><pre><code>int8
int16
int32
int64
int
byte
string
slice
func
map
</code></pre>
<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><pre><code>type typ int

type T struct &#123;
    name string
&#125;

type I interface&#123;
    Name() string
&#125;
</code></pre>
<p>在 Golang 官方定义中， 内置类型不能定义方法，接口类型是方法的无效接收者。</p>
<p>换句话说，我们只能给 <code>type T int</code> 和 <code>type T struct&#123;&#125;</code> 定义方法。</p>
<h2 id="类型元数据"><a href="#类型元数据" class="headerlink" title="类型元数据"></a>类型元数据</h2><p>无论是内置类型还是自定义类型，每种类型都有全局唯一的 <code>类型元数据</code>。</p>
<p>类型元数据记录了如下信息:(rutime/type.go)</p>
<pre><code>type _type struct &#123;
    size        uintptr
    hash        uint32
    tflag       tflag
    align       uint8
    fieldAlign  uint8
    kind        uint8
    ....
&#125;
</code></pre>
<p>有些类型元数据可能还需要对信息进行扩展，比如切片类型</p>
<pre><code>type slicetype struct &#123;
    typ     _type
    elem    *_type
&#125;
</code></pre>
<p>因为切片类型可以是整型切片，也可以是字符串切片，因此，它还需要一个elem字段来描述储存元素的类型。比如整形切片，它的类型元数据的elem字段需要指向整形的类型元数据。</p>
<p>对于自定义类型，它们可能还需要更多的描述，这些描述被储存在 <code>uncommontype</code> 结构体中。</p>
<pre><code>type uncommontype struct &#123;
    pkgpath nameOff
    mcount  uint16 // 方法数
    xcount  uint16 // exported方法数
    moff    uint32 // 相对于方法元数据数据的偏移值
    _       uint32 // unused
&#125;
</code></pre>
<h2 id="类型的两种写法区别"><a href="#类型的两种写法区别" class="headerlink" title="类型的两种写法区别"></a>类型的两种写法区别</h2><ul>
<li><code>type MyType1 = int32</code><ul>
<li><code>Mytype1</code> 和 <code>int32</code> 会被关联到同一个类型元数据，比如 <code>rune</code> 和 <code>int32</code> 就是这样的关系。</li>
</ul>
</li>
<li><code>type MyType2 int32</code><ul>
<li><code>MyType2</code> 和 <code>int32</code> 会各自拥有自己的类型元数据。</li>
</ul>
</li>
</ul>
<h1 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h1><h2 id="空接口类型"><a href="#空接口类型" class="headerlink" title="空接口类型"></a>空接口类型</h2><p>空接口类型可以接收任意类型的数据，也就是说它需要记录接收数据的类型和数据的地址。</p>
<pre><code>type eface struct &#123;
    _type *_type            // 动态类型
    data  unsafe.Pointer    // 动态值
&#125;
</code></pre>
<p>下图展示了一个空接口变量赋值后，其元数据的变化。</p>
<p><img src="https://i.loli.net/2021/06/09/93lIxa4JU6GHAZj.png" alt="interface.png"></p>
<h2 id="非空接口类型"><a href="#非空接口类型" class="headerlink" title="非空接口类型"></a>非空接口类型</h2><p>非空接口类型即拥有一个方法列表的类型。一个变量要想赋值给一个非空接口类型，它需要实现这个接口所有的方法。</p>
<pre><code>type iface struct &#123;
    tab  *itab
    data unsafe.Pointer // 指向接口的动态值
&#125;
</code></pre>
<p><img src="https://i.loli.net/2021/06/09/NtDmKZUFSEWP2i3.png" alt="non-nil-interface.png"></p>
<p>非空接口的 </p>
<ul>
<li><code>tab.inter</code> 指向了接口类型的元数据，其中的 <code>mhdr</code> 是接口的方法列表。</li>
<li><code>_type</code> 是接口的动态类型</li>
<li><code>hash</code> 是类型哈希值，用于接口类型的快速比较</li>
<li><code>fun</code> 是方法地址数组</li>
</ul>
<p>itab 结构体中的值，在它被确定后就不会发生改变，所以它是可复用的。</p>
<p><img src="https://i.loli.net/2021/06/09/7HebRa1sKAwzqyk.png" alt="itab.png"></p>
<p>Golang 会将接口类型和动态类型作为一个组合key， itab结构体指针为value, 形成一张轻量级的哈希表。当我们需要一个itab时，会先在哈希表中查找，如果找到了，直接复用，否则会创建一个新的itab，添加到这张哈希表中。</p>
<h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>像上面提到的 <code>空接口</code> 和 <code>非空接口</code> ，被叫做 <code>抽象类型</code>; 与之对应的 int, string, slice 等类型就是具体类型。</p>
<p>类型断言是作用在抽象类型之上的， 而断言的目标类型，可以是具体类型，也可以是非空接口。两两组合，可以得到4种断言。</p>
<ul>
<li>空接口.(具体类型)</li>
<li>非空接口.(具体类型)</li>
</ul>
<h2 id="空接口-具体类型"><a href="#空接口-具体类型" class="headerlink" title="空接口.(具体类型)"></a>空接口.(具体类型)</h2><p><code>r, ok := interface.(*type)</code></p>
<p>对于这种类型断言，我们只需要检查 interface 元数据中的 <code>_type</code> 字段是否指向 断言的<code>*type</code>， 是则 Ok 为 true, 否则 ok 为 false，且 r 为 nil</p>
<h2 id="非空接口-具体类型"><a href="#非空接口-具体类型" class="headerlink" title="非空接口.(具体类型)"></a>非空接口.(具体类型)</h2><p>与空接口不同的是，这种断言方法只需检查 itab 是否指向目标类型结构体。</p>
<h2 id="空接口-非空接口"><a href="#空接口-非空接口" class="headerlink" title="空接口.(非空接口)"></a>空接口.(非空接口)</h2><p>在我们检查接口类型元数据时， 我们需要比对 空接口的方法元数据数组和目标类型的方法列表是否相同。当然我们不通过空接口的类型元数据直接比对，还是通过itab缓存。但是通过itab缓存时，虽然查到了目标itab，但还是需要比对itab中的方法 <code>f[0]</code> 是否为 0。 这是因为，在某次类型断言失败时，itab缓存还是会添加itab到哈希表中，只是会将其方法列表置0，代表断言失败。</p>
<h2 id="非空接口-非空接口"><a href="#非空接口-非空接口" class="headerlink" title="非空接口.(非空接口)"></a>非空接口.(非空接口)</h2><p>同样，从itab缓存查itab结构体指针，并去查f[0]是否为0.</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Golang 的类型断言的关键在于明确接口动态类型，与对应类型实现了哪些方法。</p>
<p>这些明确内容的关键点在于 <code>类型元数据</code> <code>空接口</code> <code>非空接口</code></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/06/09/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8Golang%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2021/06/08/vsCode-%E6%B7%BB%E5%8A%A0%E8%87%B3%E5%8F%B3%E9%94%AE/"
                            aria-label=": vsCode 添加至右键"
                        >
                            vsCode 添加至右键
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-06-08T09:44:07+08:00">
	
		    6月 08, 2021
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>将下列配置粘到一个新建的 <code>xxx.reg</code> 文件中</li>
</ul>
<pre><code>Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\*\shell\VSCode]
@=&quot;Open with Code&quot;
&quot;Icon&quot;=&quot;C:\\Program Files\\Microsoft VS Code\\Code.exe&quot;

[HKEY_CLASSES_ROOT\*\shell\VSCode\command]
@=&quot;\&quot;C:\\Program Files\\Microsoft VS Code\\Code.exe\&quot; \&quot;%1\&quot;&quot;

Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\Directory\shell\VSCode]
@=&quot;Open with Code&quot;
&quot;Icon&quot;=&quot;C:\\Program Files\\Microsoft VS Code\\Code.exe&quot;

[HKEY_CLASSES_ROOT\Directory\shell\VSCode\command]
@=&quot;\&quot;C:\\Program Files\\Microsoft VS Code\\Code.exe\&quot; \&quot;%V\&quot;&quot;

Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode]
@=&quot;Open with Code&quot;
&quot;Icon&quot;=&quot;C:\\Program Files\\Microsoft VS Code\\Code.exe&quot;

[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode\command]
@=&quot;\&quot;C:\\Program Files\\Microsoft VS Code\\Code.exe\&quot; \&quot;%V\&quot;&quot;
</code></pre>
<p>注意路径和实际是否一致。</p>
<p>实际就是添加注册表</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2021/06/08/vsCode-%E6%B7%BB%E5%8A%A0%E8%87%B3%E5%8F%B3%E9%94%AE/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/2021/06/page/2/"
                aria-label="下一页"
            >
              <span>下一页</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 1 页 共 2 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2021 Jiaget. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        



    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Avatar.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">Jiaget</h4>
        
            <div id="about-card-bio"><p>Make it correst, make it clear, make it concise, make it fast. In that order</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Unemployed</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-vrbxykgb2guqp0d1c0bvofzw2fqgddegscic3ljwk3fce6l7uqstblyu0kfc.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
