---
title: Redis 相关场景
date: 2021-06-01 20:49:03
tags:
    - nosql
    - 高并发
categories: nosql
---
# Redis 使用的基本使用场景
![redis.png](https://i.loli.net/2021/06/04/5Xs86n1NctQjK3e.png)

# Redis 与 数据库数据的一致性问题

## 抛出问题

```
    当对数据进行修改时，应该先删除缓存还是先写入数据库中？
```

### （方案一） 先删缓存， 后写数据库。

- 在高并发的场景下，线程1删除缓存，还未写入数据时，线程2开始读数据，它会读到一个nil，并从数据库中读旧数据, 线程2开始更新缓存。此时，线程1数据成功写入，并更新了缓存，之后线程2将旧数据覆盖了线程1写入的新数据。这就造成了数据不一致 `（cache old : db new)`

    
||Thread1|Thread2|
|--|--|--|
|t1|delete cache||
|t2||read -> (cache)nil ->（DB）old data|
|t3|write DB -> update cache||
|t4||write cache (overwrite)|

#### 解决方案

- 1. 不删除缓存，而是将缓存改成一个特殊值（比如 `locking`）。在客户端的设计上，读到该特殊值，就休眠一会，再查Redis
    - 缺陷：
    - 1. 特殊值对业务的侵入。（必须挑选一个与业务严格无关的值）
    - 2. 休眠时间可能重复，降低性能。

- 2. 延时双删。 删缓存 -> 写数据库 -> 休眠一会 -> 删除缓存
    - 缺陷
    - 1.写操作频繁的场景下，仍然无法避免脏数据。

不能在写操作频繁的情况下使用

### （方案二）先写数据，再删缓存

- 数据库写完后，缓存删除失败，数据就会不一致。

#### 解决方案：

- 1. 给缓存设置过期时间。
    - 缺陷
    - 过期时间内，缓存数据未更新，仍有脏数据风险。

- 2. 引入MQ, 保证原子性， 删除缓存失败，会重试
    - 缺陷
    - 重试时间内，仍然存在脏数据。

- 3. 业务不再处理脏数据的问题。业务层只需要给value设置一个逻辑过期时间。另开一个线程，用来扫描缓存，并删除过期的缓存。

只能保证最终一致性，而不能保证实时一致。

# Redis 缓存穿透
缓存中查不到，数据库中也查不到。(不断地去查数据库中不存在的数据。)

- 解决方案
    1. 对参数进行合法性校验
    2. 将查询不到的数据写入数据库。（Redis会记录很多无效key.可以将不合法数据过期时间设置短一点。）
    3. 引入布隆过滤器（BloomFilter），访问Redis前，数据是否存在。布隆过滤器存在一定误判率，且只能加数据，不能减

# Redis 缓存击穿
缓存中没有数据，但是数据库中有数据。（缓存数据初始化，或者key过期。 ）

高并发场景下，过期key写入缓存的延时中，出现大量访问该key的线程，由于缓存中不存在该key。数据库将承受巨大压力。

- 解决方案
    1. 热点缓存永不过期。但是要注意value需要有逻辑过期时间。在另一个线程定期更新该数据。（对系统存在损耗）
    2. 避免DB承受并发压力：DB给redis写入key时，加锁，让访问该key的线程等待，避免压力击穿redis到DB上
# Redis 缓存雪崩

缓存大面积过期，请求全部转发到DB。

- 解决方案：
    1. 将缓存过期时间分散开。 在原有的统一的过期时间基础上，增加随机值。
    2. 对于分布式系统，可以将热点数据分散到不同节点上。